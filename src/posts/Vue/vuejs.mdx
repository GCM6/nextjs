---
title: "Vue3原理笔记"
date: "2024-10-26"
---

## Vue3 原理笔记

### 框架设计篇

**运行时和编译时**

>一般的框架一般有三种选择：纯运行时，运行时+编译时，纯编译时,vue3是一个编译时+运行时的框架

* 运行时： 提供一个runTime 去进行render，纯运行的框架无法分析用户提供的内容

* 编译时： 就是在编译阶段直接编译成可执行的js代码，性能更好

**命令式和声明式**

> 视图层框架通常分为命令式和声明式,VueJS 是一个声明式框架

- 命令式：jquery 就是比较典型的命令式框架，命令式框架一大特点就是关注过程

- 声明式：声明式的框架于命令式的框架关注过程不同，声明式框架更加关注结果

命令式的代码性能优于声明式的代码：

- 命令式代码消耗性能为 1

- 声明式代码的消耗性能为 2（修改结果为 1，找出差异的过程为 1，性能相加则为 2 声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗
   ）

**引出：vue 是内部实现是通过命令式的，而暴露给到用户的却是声明式的**

**Vue3的设计思路**

Vue3是一个声明式的UI框架，也就是通过模版去描述Ui但是同时又支持js对象去描述UI,他们都属于声明式地描述UI。

**模板的工作原理**

> 编译器--> 渲染函数--> 虚拟 dom--> 渲染器--> 真实 dom

模板通过编译器编译成渲染函数，当然无论是使用模板还是手写的渲染函数，对于一个组件来说它要渲染的内容最终都是渲染函数产生的，然后渲染器再把渲染函数返回的虚拟 dom 渲染成真实 dom。
这就是模板的工作原理，也是 vue 渲染页面的流程。


**虚拟 dom 解决了什么**

>组件的本质：本质也就是一个函数返回虚拟dom 也就是vnode

虚拟 dom 就是为了最小化找出差异这一步的性能消耗而出现的。而它要解决的问题就是写声明式的代码还能够保证程序的性能下限，让程序的性能不至于太差，甚至想办法逼近命令式代码的性能


innerHTML 的性能跟虚拟 dom 对比：

* innerHTML 为了渲染出页面，首先要把字符串解析成 dom 树，这是一个 dom 层面的计算，dom 层的计算消耗计算性能是比较大的，而且 innerHTML 它还要加上 HTML 字符串拼接的计算量。
* 而虚拟 dom 则是创建 js 对象的计算量加上创建真实 dom 的计算量，目前看起来 2 个性能差距好像不大，但是 innerHTML 在更新页面的时候，哪怕修改了一个字也要销毁所有旧的 dom 元素然后再创建一个新的 dom 元素，而虚拟 dom 在更新页面的时候则是先找到新旧的差异，然后进行差异更新。而且 diff 的性能消耗是 js 层的计算，页面越大更新的时候 innerHTML 消耗的性能越大，因为它是全量更新。

**vue3框架的Tree-shark**

Tree-shaking: 本身基于ESM进行dead code 删除无用的code,但是如果一个函数调用会产生副作用，Tree-shaking就不会将其移除

### 响应式篇

原始值：``` Boolean、Number、BigInt、String、Symbol、undefined、null等类型。在js中原始值是按值传递，而非引用传递。```

**原始值的响应方案**

***ref方案：***

由于Proxy的代理目标必须是非原始值，所以我们没有任何手段拦截对原始值的操作。唯一的办法是通过使用一个非原始值去包裹原始值，比如通过对象去包裹，但是会出现2个问题，
- 用户为了创建一个响应式的原始值，不得不顺带创建一个包裹的对象
- 包裹的对象由用户定义，而这意味着不规范，用户可以随意命名，所以出现了ref

使用ref为每个包裹对象进行增加一个属性__v_isRef，这个属性是不可以枚举的，从而进行判断这个是不是ref了,模板使用ref的值为什么可以不用写value，因为在到处setup的值后有一个对应的方法进行处理了


**Vue 代理数组**    

- [源码数组方法重写](https://github1s.com/vuejs/core/blob/main/packages/reactivity/src/arrayInstrumentations.ts)

- 数组本身也是一个对象，它跟普通对象的区别是数组对象部署的内部方法[[DefineOwnProperty]]。在执行数组对象的内部方法的[[Set]]时候，[[Set]]是依赖于[[DefineOwnProperty]]的。
- 数组的方法如 includes 方法为了找到给定的值它内部会访问数组的 length 属性以及数组的索引，但是我们知道监听数组的响应式是监听数组的 length 属性。
- 数组的方法如 push 方法，在 push 的时候会触发 2 次依赖收集，一次是 length 的读取一次是 push 的，这是个问题，所以需要我们在 get 中把一次给取消了，这就需要重写数组方法设置一个状态了。

**代理 Set 和 Map**

当我们使用代理的对象来去访问一个size就会发现有问题，这是因为Set.prototype.size是一个访问器属性，因为我们是通过代理对象来访问size属性的，所以this就是代理属性，但是this没有对应内部方法，所以就会报错。所以需要通过Refect来重新指定第三个参数也就是this的指向为原始target，这样就行了。

- `Set`和`Map`这 2 个数据类型的操作方法相似，最大的不同是`Set`是通过 add 添加元素而`Map`是通过 set 添加元素。
- [Set.prototype.set 是一个属性访问器](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/size)。

**Watch vs watchEffect**

Watch 和watchEffect 都能响应式地执行有副作用的回调，他们之前主要的区别是追踪响应式的依赖的方式：
- Watch只追踪明确侦听的数据源。它不会追着任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch避免发生副作用时追踪依赖，因此我们更加精确地控制回调函数的触发时机。
- watchEffect 则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码更简洁，但是有时其响应性依赖关系没有那么明确

**总结：**

- watch : 需要明确指定要侦听的数据源，只有这些数据源发生变化时才触发回调，所以可以更加精确地控制回调函数触发时机。

- watchEffect: 自动追踪在副作用中访问的所有响应式属性。每次运行时都会重新收集依赖，使用起来更方便，但是依赖关系就不是很明确。

### 渲染器

 渲染器是用来执行渲染让我的，在浏览器平台上用它来渲染其中的真实dom元素，而且不仅可以渲染真实dom还提供跨平台的能力。实际上，在vue3中，甚至连创建应用的createApp函数也是渲染器的一部份。

 >挂载： 渲染器把虚拟dom节点渲染为真实的dom节点的过程叫做挂载。
 
 **知识点**

- Render函数的执行过程中大致就是进行patch的过程，主要是比对新老vnode,然后进行挂载。

- 浏览器解析html代码后会自动分析``` HTML Attributes``` 并设置合适的 ```DOM Properties```，也就是```HTML Attributes``` 的作用就是设置与之对应的```DOM Properties```的初始值。 
通过```setAttribute``` 函数设置的值总是会被字符串化，所以在针对布尔值的时候要注意

- 在浏览器中为一个元素设置```class```有三种方式，即使用```setAttribute```、```el.className```、```el.classList```。但是```el.className```性能最优。

- 通过使用```innerHTML``` 清空容器元素内容的缺陷是，它不会移除绑定在```dom```元素上的事件处理函数。

- Vue3通过使用```Fragment``` 的方式去支持多跟节点模板