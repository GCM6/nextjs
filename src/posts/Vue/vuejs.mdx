---
title: "Vue3原理笔记"
date: "2024-10-26"
---

## Vue3 原理笔记

### 框架设计篇

**运行时和编译时**

>一般的框架一般有三种选择：纯运行时，运行时+编译时，纯编译时,vue3是一个编译时+运行时的框架

* 运行时： 提供一个runTime 去进行render，纯运行的框架无法分析用户提供的内容

* 编译时： 就是在编译阶段直接编译成可执行的js代码，性能更好

**命令式和声明式**

> 视图层框架通常分为命令式和声明式,VueJS 是一个声明式框架

- 命令式：jquery 就是比较典型的命令式框架，命令式框架一大特点就是关注过程

- 声明式：声明式的框架于命令式的框架关注过程不同，声明式框架更加关注结果

命令式的代码性能优于声明式的代码：

- 命令式代码消耗性能为 1

- 声明式代码的消耗性能为 2（修改结果为 1，找出差异的过程为 1，性能相加则为 2 声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗
   ）

**引出：vue 是内部实现是通过命令式的，而暴露给到用户的却是声明式的**

**Vue3的设计思路**

Vue3是一个声明式的UI框架，也就是通过模版去描述Ui但是同时又支持js对象去描述UI,他们都属于声明式地描述UI。

**模板的工作原理**

> 编译器--> 渲染函数--> 虚拟 dom--> 渲染器--> 真实 dom

> 编译器（识别那些是静态属性，那些是动态属性） —编译—> 渲染函数—渲染—> 虚拟dom --渲染器（根据编译器的配合标识然后寻找并且只更新变化的内容）—>渲染真实dom


模板通过编译器编译成渲染函数，当然无论是使用模板还是手写的渲染函数，对于一个组件来说它要渲染的内容最终都是渲染函数（render函数）产生的，然后渲染器再把渲染函数（render函数）返回的虚拟 dom 渲染成真实 dom。
这就是模板的工作原理，也是 vue 渲染页面的流程。


**虚拟 dom 解决了什么**

>组件的本质：本质也就是一个函数返回虚拟dom 也就是vnode

虚拟 dom 就是为了最小化找出差异这一步的性能消耗而出现的。而它要解决的问题就是写声明式的代码还能够保证程序的性能下限，让程序的性能不至于太差，甚至想办法逼近命令式代码的性能


innerHTML 的性能跟虚拟 dom 对比：

* innerHTML 为了渲染出页面，首先要把字符串解析成 dom 树，这是一个 dom 层面的计算，dom 层的计算消耗计算性能是比较大的，而且 innerHTML 它还要加上 HTML 字符串拼接的计算量。
* 而虚拟 dom 则是创建 js 对象的计算量加上创建真实 dom 的计算量，目前看起来 2 个性能差距好像不大，但是 innerHTML 在更新页面的时候，哪怕修改了一个字也要销毁所有旧的 dom 元素然后再创建一个新的 dom 元素，而虚拟 dom 在更新页面的时候则是先找到新旧的差异，然后进行差异更新。而且 diff 的性能消耗是 js 层的计算，页面越大更新的时候 innerHTML 消耗的性能越大，因为它是全量更新。

虚拟dom的缺点：

- 增加包的体积

**vue3框架的Tree-shark**

Tree-shaking: 本身基于ESM进行dead code 删除无用的code,但是如果一个函数调用会产生副作用，Tree-shaking就不会将其移除

### 响应式篇

原始值：``` Boolean、Number、BigInt、String、Symbol、undefined、null等类型。在js中原始值是按值传递，而非引用传递。```

**原始值的响应方案**

***ref方案：***

由于Proxy的代理目标必须是非原始值，所以我们没有任何手段拦截对原始值的操作。唯一的办法是通过使用一个非原始值去包裹原始值，比如通过对象去包裹，但是会出现2个问题，
- 用户为了创建一个响应式的原始值，不得不顺带创建一个包裹的对象
- 包裹的对象由用户定义，而这意味着不规范，用户可以随意命名，所以出现了ref

使用ref为每个包裹对象进行增加一个属性__v_isRef，这个属性是不可以枚举的，从而进行判断这个是不是ref了,模板使用ref的值为什么可以不用写value，因为在到处setup的值后有一个对应的方法进行处理了


**Vue 代理数组**    

- [源码数组方法重写](https://github1s.com/vuejs/core/blob/main/packages/reactivity/src/arrayInstrumentations.ts)

- 数组本身也是一个对象，它跟普通对象的区别是数组对象部署的内部方法[[DefineOwnProperty]]。在执行数组对象的内部方法的[[Set]]时候，[[Set]]是依赖于[[DefineOwnProperty]]的。
- 数组的方法如 includes 方法为了找到给定的值它内部会访问数组的 length 属性以及数组的索引，但是我们知道监听数组的响应式是监听数组的 length 属性。
- 数组的方法如 push 方法，在 push 的时候会触发 2 次依赖收集，一次是 length 的读取一次是 push 的，这是个问题，所以需要我们在 get 中把一次给取消了，这就需要重写数组方法设置一个状态了。

**代理 Set 和 Map**

当我们使用代理的对象来去访问一个size就会发现有问题，这是因为Set.prototype.size是一个访问器属性，因为我们是通过代理对象来访问size属性的，所以this就是代理属性，但是this没有对应内部方法，所以就会报错。所以需要通过Refect来重新指定第三个参数也就是this的指向为原始target，这样就行了。

- `Set`和`Map`这 2 个数据类型的操作方法相似，最大的不同是`Set`是通过 add 添加元素而`Map`是通过 set 添加元素。
- [Set.prototype.set 是一个属性访问器](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/size)。

**Watch vs watchEffect**

Watch 和watchEffect 都能响应式地执行有副作用的回调，他们之前主要的区别是追踪响应式的依赖的方式：
- Watch只追踪明确侦听的数据源。它不会追着任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch避免发生副作用时追踪依赖，因此我们更加精确地控制回调函数的触发时机。
- watchEffect 则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码更简洁，但是有时其响应性依赖关系没有那么明确

**总结：**

- watch : 需要明确指定要侦听的数据源，只有这些数据源发生变化时才触发回调，所以可以更加精确地控制回调函数触发时机。

- watchEffect: 自动追踪在副作用中访问的所有响应式属性。每次运行时都会重新收集依赖，使用起来更方便，但是依赖关系就不是很明确。

### 渲染器

 渲染器的作用是把虚拟dom渲染为特定平台上的真实元素，在浏览器平台上用它来渲染其中的真实dom元素，而且不仅可以渲染真实dom还提供跨平台的能力。实际上，在vue3中，甚至连创建应用的createApp函数也是渲染器的一部份。

 >挂载： 渲染器把虚拟dom节点渲染为真实的dom节点的过程叫做挂载。

 **Vue 组件挂载时会发生如下几件事：**

- 编译：Vue 模板被编译为渲染函数：即用来返回虚拟 DOM 树的函数。这一步骤可以通过构建步骤提前完成，也可以通过使用运行时编译器即时完成。

- 挂载：运行时渲染器调用渲染函数，遍历返回的虚拟 DOM 树，并基于它创建实际的 DOM 节点。这一步会作为响应式副作用执行，因此它会追踪其中所用到的所有响应式依赖。

- 更新：当一个依赖发生变化后，副作用会重新运行，这时候会创建一个更新后的虚拟 DOM 树。运行时渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实 DOM 上去。
 
 **知识点**

- Render函数的执行过程中大致就是进行patch的过程，主要是比对新老vnode,然后进行挂载。

- 浏览器解析html代码后会自动分析``` HTML Attributes``` 并设置合适的 ```DOM Properties```，也就是```HTML Attributes``` 的作用就是设置与之对应的```DOM Properties```的初始值。 
通过```setAttribute``` 函数设置的值总是会被字符串化，所以在针对布尔值的时候要注意

- 在浏览器中为一个元素设置```class```有三种方式，即使用```setAttribute```、```el.className```、```el.classList```。但是```el.className```性能最优。

- 通过使用```innerHTML``` 清空容器元素内容的缺陷是，它不会移除绑定在```dom```元素上的事件处理函数。

- Vue3通过使用Fragment 的方式去支持多跟节点模板, 而且Fragment 类型并不会进行渲染，只会渲染它的子节点。

### Diff算法

diff算法主要为了解决直接操作dom的性能开销通常比较大。像是slevtejs没用虚拟dom的性能开销也挺好，是因为slevte是纯编译时的框架。

> key的作用: 在虚拟dom进行patch时通过key作为vnode的标识，如果key相同那么就可以进行dom复用，但是可复用不意味着不需要更新，主要是为了避免过多地对dom元素进行销毁和重建。

#### 1、简单diff

在diff过程中，在进行新旧两组子节点的更新对比时，应该遍历其中长度比较短的那一组，这样才能够尽可能的多调用patch函数进行更新（通过两组子节点公共长度，也就是两者中较短的那一组的子节点的长度然后进行patch，因为单纯遍历某一组节点进行patch的时候不能保证多patch），然后再比对新旧节点的长度，如果新节点更长，则说明有新节点需要挂载，否则就是有旧节点需要卸载。

- 先patch 公共部分，也就是2组节点最短的一组的长度进行新旧节点patch。
- 如果新节点长度比旧节点长度大，说明有新节点需要挂载也就是新增。
- 如果旧节点长度比新节点长度大，说明旧节点需要卸载。



**如何移动：**

> diff比对判断是否需要移动元素：在diff的过程如何判断节点是否需要移动，只需要判断根据新节点和旧节点对比出位置索引如果不是递增的趋势则需要移动。

首先虚拟dom中el的属性就是对真实dom节点的引用，然后根据有了引用那么就可以进行对真实dom元素进行移动了。

大概的移动逻辑：
- 如果需要移动，那么就获取当前新节点的前一个节点，如果前一个节点不存在，那么说明当前的节点就是第一个节点它不需要移动。
- 如果前一个节点存在，由于我们需要将当前节点对应的真实dom节点移动到前一个节点所对应的真实dom的后面，所以需要获取前一个节点对应真实dom的下一个兄弟节点，将其作为喵点（因为就是在这个喵点的前面去插入）


**添加新元素**

分为2步：
- 想办法找到新增的节点。
- 将新增的节点挂载到正确的位置。

第一步： 遍历查找旧一组节点中有没有可复用的节点，那就是新增节点，然后需要挂载。

第二步： 先找到对应的喵点，先获取当前节点的前一个虚拟节点，如果获取到了则使用它对应的el（真实dom的引用属性）对应的真实dom的下一个兄弟节点作为喵点元素，如果当前节点没有前一个节点，说明挂载的新节点是第一个子节点，直接使用容器元素的firstChild作为锚点，然后完成挂载。

**删除元素**

当更新结束之后，我们需要通过遍历旧的一组子节点，然后去新的一组子节点中寻找具有相同的key值的节点，如果没找到，则说明应该删除该子节点。

#### 双端diff算法（vue2）

双端diff算法是一种同时对新旧两组子节点的四个端点进行比较的算法，需要四个索引值，分别指向新旧两组子节点端点。分别为新旧头部节点跟尾部节点然后试图找到可复用的节点。


**理想情况下比较步骤：**

- 新头部节点跟旧头部节点比较key如果key不同，不可复用则什么也不做。（头部跟头部）
- 比较2组节点的尾部节点，如果key相同，那么可以复用，2个都在尾部，所以不需要移动，直接patch就行，然后更新索引和头尾部节点的变量。（尾部跟尾部）
- 新节点尾部节点跟旧节点头部比较进行比较，如果key一致则复用，进行patch和移动，更新索引跟节点值（尾部跟头部）
- 新节点头部跟旧节点尾部比较，跟上面一致的处理（头部跟尾部）
- 最后新旧两组节点的头部跟尾部索引都发生重合的情况下，那么不需要移动，只需要patch打补丁即可。
循环往复去比较，直到结束

**非理想去看下的处理：**

- 通过把新一组节点的头部节点的key到旧一组节点中寻找，如果找到相同的key，说明原本新节点的头部在旧节点中不是头部，更新后变成了头部。
- 那么这时候需要把寻找到的旧节点对应的真实dom节点移动到旧节点的头部，变为头部并进行patch，然后把旧节点的对应这个值置undefined。
- 处理完后把新节点的头部索引前进到下一位置。之后继续上面理想的双端算法的步骤

**添加新元素：**

因为理想情况下去比对的时候都没找到对应的key,然后进行非理想情况寻找，还是没找到，那么就可以判断出是新增的节点，然后把它挂载到正确的位置。

当上面的循环diff结束后也就是都找到满足复用的情况下可能会遗漏新增的节点元素，所以增加一个检查四个索引值的情况如果旧节点尾索引小于头节点索引且新节点的头索引小于等于尾索引则说明遗漏了新节点，所以需要遍历进行挂载。

**移除元素：**

当旧节点头部索引小于等于尾部索引的时候说明有需要卸载掉元素，所以需要在上面diff双端比对完后进行遍历卸载。


双端diff比较的优势：
在同样的更新场景下，执行dom移动操作次数更少。

#### 快速diff算法（vue3）